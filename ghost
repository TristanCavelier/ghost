#!/bin/bash

version="2.0.1"

#  Copyright (c) 2014 Tristan Cavelier <t.cavelier@free.fr>
#
#  This program is free software. It comes without any warranty, to
#  the extent permitted by applicable law. You can redistribute it
#  and/or modify it under the terms of the Do What The Fuck You Want
#  To Public License, Version 2, as published by Sam Hocevar. See
#  below for more details.
#
#  ___________________________________________________________________
# |                                                                   |
# |           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE             |
# |                   Version 2, December 2004                        |
# |                                                                   |
# |Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>                   |
# |                                                                   |
# |Everyone is permitted to copy and distribute verbatim or modified  |
# |copies of this license document, and changing it is allowed as long|
# |as the name is changed.                                            |
# |                                                                   |
# |           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE             |
# |  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  |
# |                                                                   |
# | 0. You just DO WHAT THE FUCK YOU WANT TO.                         |
# |___________________________________________________________________|

# dependencies:
# cut
# dd
# grep
# gzip
# ls
# lsblk
# mkswap
# partclone (optional)
# sed
# sfdisk
# zcat

cmd=$(basename "$0")
usage="Usage:
    $cmd list                               # show a list of connected block devices
    $cmd restore [OPTION] [FOLDER]          # restore disks/partitions from files in FOLDER
    $cmd backup [OPTION] DEV [FOLDER]       # backup entire disk/part in FOLDER

    $cmd restore [OPTION] FILE              # restore headers/partitions from FILE
    $cmd [OPTION]

  DEV can be either DISK or PART
  DISK is disk path (ex: /dev/sda)
  PART is partition path (ex: /dev/sda1)
  FOLDER is folder path (default is current working directory)
  FILE is file path

  OPTION:
    -v, --version                  # print the program version and exit
    -h, --help                     # print this help and exit
        --info                     # print details about what this program does

  backup OPTION:
    -n, --dry-run                  # just output backup commands
    -Z, --no-gzip                  # tells to not use gzip
        --headers                  # backup disk headers only
        --parts                    # backup disk partitions only
        --dd                       # use \`dd\` only
        --partclone                # use \`partclone\` only

  restore OPTION:
    -n, --dry-run                  # just output restoration commands
"
info="\
For \`$cmd restore\`, it will look for this kind of files:
    ./DEV.dd.bin[.gz]
    ./DISK.sfdisk[.gz]
    ./DISK.start.bin
    ./DISK.mbr.bin
    ./DISK.amorce.bin
    ./PART.partclone.bin[.gz]
    ./PART.[LABEL.]UUID.mkswap (which is empty)

For \`$cmd backup -- DISK\`, it will create:
    ./DISK.start.bin
    ./DISK.mbr.bin
    ./DISK.amorce.bin
    ./DISK.sfdisk.gz
    ./PART.partclone.bin.gz (or PART.dd.bin.gz if FSTYPE is not supported)
    ./PART.[LABEL.]UUID.mkswap

For \`$cmd backup --headers -- DISK\`, it will create:
    ./DISK.start.bin
    ./DISK.mbr.bin
    ./DISK.amorce.bin
    ./DISK.sfdisk.gz

For \`$cmd backup -- PART\`, it will create:
    ./PART.partclone.bin.gz (or PART.dd.bin.gz if FSTYPE is not supported)
  or
    ./PART.[LABEL.]UUID.mkswap

(\`./\` can also be \`FOLDER/\`.)

Command used to get DEV.dd.bin: dd if=DEV of=DEV.dd.bin
restore with: dd if=DEV.dd.bin of=DEV

Command used to get DEV.dd.bin.gz: dd if=DEV | gzip -c > DEV.dd.bin.gz
restore with: zcat DEV.dd.bin.gz | dd of=DEV

Command used to get DISK.sfdisk: sfdisk -d DISK > DISK.sfdisk
restore with: sfdisk --force DISK < DISK.sfdisk

Command used to get DISK.sfdisk.gz: sfdisk -d DISK | gzip -c > DISK.sfdisk.gz
restore with: zcat DISK.sfdisk.gz | sfdisk --force DISK

Command used to get DISK.mbr.bin: dd if=DISK of=DISK.mbr.bin bs=512 count=1
restore with: dd if=DISK.mbr.bin of=DISK bs=512 count=1

Command used to get DISK.amorce.bin: dd if=DISK of=DISK.amorce.bin bs=446 count=1
restore with: dd if=DISK.amorce.bin of=DISK bs=446 count=1

Command used to get PART.partclone.bin: partclone.FSTYPE -c -s PART > PART.partclone.bin
restore with: partclone.restore -o PART < PART.partclone.bin

Command used to get PART.partclone.bin.gz: partclone.FSTYPE -c -s PART | gzip -c > PART.partclone.bin.gz
restore with: zcat PART.partclone.bin.gz | partclone.restore -o PART

Command used to get PART.[LABEL.]UUID.mkswap: echo -n > PART.[LABEL.]UUID.mkswap
restore with: mkswap [-L LABEL] -U UUID PART
"

#         --tar                      # XXX
#     ./PART.[LABEL.]FSTYPE.UUID.tar.gz  (see ghost-tar)
# Command used to get PART.[LABEL.]FSTYPE.UUID.tar.gz: tar czf PART.[LABEL.]FSTYPE.UUID.tar.gz -X MOUNTDIRS -C MOUNTPOINT FILES -C /tmp/<tmp> MOUNTDIRSREFERENCES
# restore with: mkfs.FSTYPE [-L LABEL] -U UUID PART && tar xf PART.[LABEL.]FSTYPE.UUID.tar.gz -C MOUNTPOINT
#
# MOUNTDIRREFERENCES are folders that reflect original folders which are used as mountpoints... however, I don't know how to get information about original folder
#     mkdir mirrorfolder
#     chmod --reference=originalfolder mirrorfolder
#     chown --reference=originalfolder mirrorfolder

seeusage="Run \`$cmd --help\` to get more informations."
unknown_errno=4
invalid_request_errno=3
unknown_command_errno=3
unknown_action_errno=3
unknown_option_errno=3
unknown_device_type_errno=2
invalid_partition_errno=2
process_stopped_errno=1
process_error_errno=1


__print_color() {
   local nl='\n'
   local color="$1"
   shift
   [ "$1" = -n ] && nl= && shift
   printf "$color%s\x1b[0m$nl" "$*"
}
__print_no_color() {
   local nl='\n'
   shift
   [ "$1" = -n ] && nl= && shift
   printf "%s$nl" "$*"
}
__print_cmd=__print_color
log() { $__print_cmd '' "$@" ;}
info() { $__print_cmd '\x1b[36;1m' "$@" ;}
warn() { $__print_cmd '\x1b[33;1m' "$@" 1>&2 ;}
err() { $__print_cmd '\x1b[31;1m' "$@" 1>&2 ;}
nl="
"

######################################################################
# Chars forbidden in ntfs "/\?<>:
# Name separator is .
# Name escape char pattern is %HH (where H is a hexadecimal digit)

encode-name-component() {
    local tmp="$1"
    tmp=${tmp//%/%25}
    tmp=${tmp//\"/%22}
    tmp=${tmp//\//%2F}
    tmp=${tmp//\?/%5C}
    tmp=${tmp//</%3F}
    tmp=${tmp//>/%3C}
    tmp=${tmp//:/%3A}
    tmp=${tmp//./%2E}
    tmp=${tmp// /%20}
    printf "%s" "$tmp"
}

decode-name-component() {
    local tmp="$1"
    tmp=${tmp//%20/ }
    tmp=${tmp//%2[eE]/.}
    tmp=${tmp//%3[aA]/:}
    tmp=${tmp//%3[cC]/>}
    tmp=${tmp//%3[fF]/<}
    tmp=${tmp//%5[cC]/\?}
    tmp=${tmp//%2[fF]/\/}
    tmp=${tmp//%22/\"}
    tmp=${tmp//%25/%}
    printf "%s" "$tmp"
}

quote() { printf "%s" \'${1//\'/\'\\\'\'}\' ; }
evallines() { echo " $1" | while IFS= read -r line ; do eval " $line" || return 1 ; done ; }

-make-restore-cmds-from-file() {
    # ADD_SORT_INDEX= IGNORE_UNKNOWN_FILES= FORBID_SUB_FOLDERS= FILE= cmd
    local basename=$(basename "$FILE")
    local qFILE=$(quote "$FILE")
    if [ -d "$FILE" ] ; then
        [ "$FORBID_SUB_FOLDERS" ] && return 0
        FOLDER="$FILE" FORBID_SUB_FOLDERS=1 -make-restore-cmds-from-folder
        return $?
    fi
    # DEV.dd.bin[.gz]
    if echo "$basename" | grep -E '^[^.]+\.dd\.bin(\.gz)?$' >/dev/null ; then
        local qdev=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'a '
        if echo "$basename" | grep '\.gz$' >/dev/null ; then
            echo "zcat $qFILE | dd of=$qdev"
        else
            echo "dd if=$qFILE of=$qdev"
        fi
    # DISK.sfdisk[.gz]
    elif echo "$basename" | grep -E '^[^.]+\.sfdisk(\.gz)?$' >/dev/null ; then
        local qdisk=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'b '
        if echo "$basename" | grep '\.gz$' >/dev/null ; then
            echo "zcat $qFILE | sfdisk --force $qdisk"
        else
            echo "sfdisk --force $qdisk < $qFILE"
        fi
    # DISK.start.bin
    elif echo "$basename" | grep -E '^[^.]+\.start\.bin$' >/dev/null ; then
        local qdisk=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'c '
        echo "dd if=$qFILE of=$qdisk count=2048"
    # DISK.mbr.bin
    elif echo "$basename" | grep -E '^[^.]+\.mbr\.bin$' >/dev/null ; then
        local qdisk=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'd '
        echo "dd if=$qFILE of=$qdisk bs=512 count=1"
    # DISK.amorce.bin
    elif echo "$basename" | grep -E '^[^.]+\.amorce\.bin$' >/dev/null ; then
        local qdisk=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'e '
        echo "dd if=$qFILE of=$qdisk bs=446 count=1"
    # PART.partclone.bin[.gz]
    elif echo "$basename" | grep -E '^[^.]+\.partclone.bin(\.gz)?$' >/dev/null ; then
        local qpart=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'f '
        if echo "$basename" | grep '\.gz$' >/dev/null ; then
            echo "zcat $qFILE | partclone.restore -o $qpart"
        else
            echo "partclone.restore -o $qpart < $qFILE"
        fi
    # PART.[LABEL.]UUID.mkswap (which is empty)
    elif echo "$basename" | grep -E '^[^.]+\.[^.]+\.[^.]+.mkswap' >/dev/null ; then
        local qpart=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        local qlabel=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 2)")")
        local quuid=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 3)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'g '
        echo "mkswap -L $qlabel -U $quuid $qpart"
    elif echo "$basename" | grep -E '^[^.]+\.[^.]+.mkswap' >/dev/null ; then
        local qpart=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 1)")")
        local quuid=$(quote "$(decode-name-component "$(echo "$basename" | cut -d . -f 2)")")
        [ "$ADD_SORT_INDEX" ] && echo -n 'g '
        echo "mkswap -U $quuid $qpart"
    else
        if [ -z "$IGNORE_UNKNOWN_FILES" ] ; then
            err "Don't know how to restore \`$FILE\`"
            return $unknown_action_errno
        fi
    fi
}

-make-restore-cmds-from-folder() {
    # FOLDER= cmd
    local _status=
    ls -1 "$FOLDER" | while IFS= read -r line ; do
        ADD_SORT_INDEX=1 IGNORE_UNKNOWN_FILES=1 FORBID_SUB_FOLDERS=1 FILE="$line" -make-restore-cmds-from-file
    done | sort | cut -d ' ' -f 2-
}

main-restore() {
    local dry_run=
    while [ $# != 0 ] ; do
        case "$1" in
            -n|--dry-run) dry_run=1 ; shift ;;
            --) shift ;;
            -*) err "Unkown option \`$1\`$nl$seeusage" ; return $unknown_option_errno ;;
            *) break ;;
        esac
    done
    if [ $# = 0 ] ; then
        restore_cmds=$(FOLDER=. -make-restore-cmds-from-folder)
    else
        restore_cmds=$(for p in "$@" ; do FILE="$p" -make-restore-cmds-from-file ; done) || return $?
    fi
    [ -z "$restore_cmds" ] && { warn "Nothing to backup" ; return $process_stopped_errno ; }
    echo "$restore_cmds"
    [ $dry_run ] && return 0
    echo -n "
Start restore? [y/N] "
    local answer=
    IFS= read -r answer
    [ "$answer" != y ] && { warn "Aborting" ; return $process_stopped_errno ; }
    evallines "$backup_cmds"
}

blk-label() { lsblk -rno LABEL "$1" | head -n 1 ; }
blk-uuid() { lsblk -rno UUID "$1" | head -n 1 ; }
blk-uuids() { lsblk -rno UUID "$1" ; }
blk-type() { lsblk -rno TYPE "$1" | head -n 1 ; }
blk-fstype() { lsblk -rno FSTYPE "$1" | head -n 1 ; }
sfdisk-start() {
    local start=
    start=$(sfdisk -d "$1" 2>/dev/null | grep -v 'size= *0,' | grep -o 'start= *[0-9]*' | sort | head -n 1 | grep -o '[0-9]*$')
    [ "${PIPESTATUS[0]}" != 0 ] && return $process_error_errno
    [ ${start:-0} -gt 2048 ] && echo 2048 || echo $start
}
ls-part-of-disk() { lsblk -rno KNAME,TYPE | grep 'part$' | grep -E -o '^\S+' | sed 's,^,/dev/,g' ; }

-make-backup-cmds-for-dd-entire-disk() {
    # USE_GZIP= DISK= FOLDER= cmd
    if [ "$USE_GZIP" ] ; then
        echo "dd if=$(quote "$DISK") | gzip -c > $(quote "$FOLDER/$(encode-name-component "$DISK").dd.bin.gz")"
    else
        echo "dd if=$(quote "$DISK") > $(quote "$FOLDER/$(encode-name-component "$DISK").dd.bin")"
    fi
}

-make-backup-cmds-for-disk() {
    # USE_ONLY_CMD= BACKUP_SELECTION= cmd
    case "${BACKUP_SELECTION:-default}" in
        default|all)
            if [ "$USE_ONLY_CMD" = dd ] ; then
                -make-backup-cmds-for-dd-entire-disk
            else
                -make-backup-cmds-for-disk-headers && -make-backup-cmds-for-disk-parts
            fi
            ;;
        headers) -make-backup-cmds-for-disk-headers ;;
        parts) -make-backup-cmds-for-disk-parts ;;
        *) err "Unknown backup selection \`$BACKUP_SELECTION\`" ; return $invalid_request_errno ;;
    esac
}

-make-backup-cmds-for-disk-headers() {
    # USE_GZIP= DISK= FOLDER= cmd
    local eDISK=$(encode-name-component "$DISK")
    local qDISK=$(quote "$DISK")
    local start= ; start=$(sfdisk-start "$DISK") || return $?
    # DISK.start.bin
    echo "dd if=$qDISK of=$(quote "$FOLDER/$eDISK.start.bin") count=$start"
    # DISK.mbr.bin
    echo "dd if=$qDISK of=$(quote "$FOLDER/$eDISK.mbr.bin") count=1 bs=512"
    # DISK.amorce.bin
    echo "dd if=$qDISK of=$(quote "$FOLDER/$eDISK.amorce.bin") count=1 bs=446"
    # DISK.sfdisk[.gz]
    if [ "$USE_GZIP" ] ; then
        echo "sfdisk -d $qDISK | gzip -c > $(quote "$FOLDER/$eDISK.sfdisk.gz")"
    else
        echo "sfdisk -d $qDISK > $(quote "$FOLDER/$eDISK.sfdisk")"
    fi
}

-make-backup-cmds-for-disk-parts() {
    # DISK= cmd
    ls-part-of-disk "$DISK" | while IFS= read -r part ; do
        PART="$part" BACKUP_SELECTION=default -make-backup-cmds-for-part
    done
}

-make-backup-cmds-for-part() {
    # USE_GZIP= BACKUP_SELECTION= USE_ONLY_CMD= PART= FOLDER= cmd
    [ "${BACKUP_SELECTION:-default}" != default ] && { err "Invalid selection \`$BACKUP_SELECTION\`" ; return $invalid_request_errno ; }
    local ePART=$(encode-name-component "$PART")
    local qPART=$(quote "$PART")
    local fstype=$(blk-fstype "$PART")
    # PART.[LABEL.]UUID.mkswap
    if [ "$fstype" = swap ] ; then
        local label=$(blk-label "$PART")
        local elabel=$(encode-name-component "$label")
        local uuid=$(blk-uuid "$PART")
        [ "$uuid" ] || { err "Part \`$PART\` has no uuid" ; return $invalid_partition_errno ; }
        echo "echo -n > $(quote "$ePART.${elabel:-}${label:+.}$uuid.mkswap")"
    # PART.parclone.bin[.gz]
    elif [ "${USE_ONLY_CMD:-partclone}" = partclone ] && which partclone."$fstype" &>/dev/null ; then
        if [ "$USE_GZIP" ] ; then
            echo "partclone.$fstype -c -s $qPART | gzip -c > $ePART.partclone.bin.gz"
        else
            echo "partclone.$fstype -c -s $qPART > $ePART.partclone.bin"
        fi
    # PART.dd.bin[.gz]
    elif [ "${USE_ONLY_CMD:-dd}" = dd ] ; then
        if [ "$USE_GZIP" ] ; then
            echo "dd if=$qPART | gzip -c > $ePART.dd.bin.gz"
        else
            echo "dd if=$ePART of=$ePART.bin"
        fi
    else
        err "No backup command found for \`$PART\`"
        return $unknown_command_errno
    fi
}

-make-backup-cmds() {
    # DEV= FOLDER= cmd
    local type=$(blk-type "$DEV" 2>/dev/null)
    case "$type" in
        disk) DISK="$DEV" -make-backup-cmds-for-disk ;;
        part) PART="$DEV" -make-backup-cmds-for-part ;;
        '') err "Unknown block device type of \`$DEV\`" ; return $unknown_device_type_errno ;;
        *) err "Unknown block device \`$type\` of \`$DEV\`" ; return $unknown_device_type_errno ;;
    esac
}

main-backup() {
    local use_gzip=1
    local dry_run=
    local backup_selection=default
    while [ $# != 0 ] ; do
        case "$1" in
            -n|--dry-run) dry_run=1 ; shift ;;
            -Z|--no-gzip) use_gzip= ; shift ;;
            --headers) backup_selection=headers ; shift ;;
            --parts) backup_selection=parts ; shift ;;
            --dd) use_only_cmd=dd ; shift ;;
            --partclone) use_only_cmd=partclone ; shift ;;
            --) shift ;;
            -*) err "Unkown option \`$1\`$nl$seeusage" ; return $unknown_option_errno ;;
            *) break ;;
        esac
    done
    [ $# = 0 ] && { err "Backup action need at least one parameter: DEV$nl$seeusage" ; return $invalid_request_errno ; }
    local folder="$2"
    [ $# -lt 2 ] && folder=.
    local backup_cmds=
    backup_cmds=$(USE_GZIP=$use_gzip USE_ONLY_CMD=$use_only_cmd BACKUP_SELECTION="$backup_selection" DEV="$1" FOLDER="$folder" -make-backup-cmds) || return $?
    [ -z "$backup_cmds" ] && { warn "Nothing to backup" ; return $process_stopped_errno ; }
    echo "$backup_cmds"
    [ $dry_run ] && return 0
    echo -n "
Start backup? [y/N] "
    local answer=
    IFS= read -r answer
    [ "$answer" != y ] && { warn "Aborting" ; return $process_stopped_errno ; }
    evallines "$backup_cmds"
}

main() {
    while [ $# != 0 ] ; do
        case "$1" in
            -h|--help) log "$usage" ; return 0 ;;
            --info) log "$info" ; return 0 ;;
            --) shift ; break ;;
            -*) err "Unkown option \`$1\`$nl$seeusage" ; return $unknown_option_errno ;;
            *) break ;;
        esac
    done
    case "$1" in
        list) lsblk -o KNAME,TYPE,FSTYPE,SIZE,LABEL,UUID,MOUNTPOINT ;;
        restore) shift ; main-restore "$@" ;;
        backup) shift ; main-backup "$@" ;;
        '') err "$seeusage" ; return $invalid_request_errno ;;
        *) err "Unknown action \`$1\`$nl$seeusage" ; return $unknown_action_errno ;;
    esac
}
main "$@"
